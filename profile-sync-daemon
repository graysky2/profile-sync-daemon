#!/bin/bash
# By graysky <graysky AT archlinux DOT us>
# Inspired by some code originally  written by Colin Verot
export BLD="\e[01m" RED="\e[01;31m" GRN="\e[01;32m" YLW="\e[01;33m" NRM="\e[00m"
VERS="5.09"

if [[ ! -f /etc/psd.conf ]]; then
	echo "Cannot find /etc/psd.conf so bailing.  Reinstall package to use Profile-sync-daemon."	# nothing to do if there is no conf file
	exit 1
else
	. /etc/psd.conf
fi

if [[ -z "$USERS" ]]; then
	echo "Must define at least one user in /etc/psd.conf"	# nothing to do if there are no users
	exit 1
fi

BROWSERS=${BROWSERS:-"chromium conkeror.mozdev.org firefox google-chrome heftig-aurora midori opera opera-next qupzilla"} # all supported browsers

[[ -z "$VOLATILE" ]] && VOLATILE="/tmp"

DAEMON_FILE=${DAEMON_FILE:-"/run/psd"}	# make it overrideable from the commandline / config

root_check() {
	# we call this to ensure that only the root user is calling the function
	# why care? both the sync and unsync functions require root access to /run/psd (the pseudo pid file)
	# running as unprivileged user will fuck up the sync process resulting in unhappy users

	if [[ $EUID -ne 0 ]]; then
		echo "This function must be called as root!" 1>&2
		exit 1
	fi
}

set_which() {
	### Arrays
	# profileArr is transient used to store profile paths parsed from firefox from and aurora
	# DIRArr is a full path corrected for both relative and absolute paths

	local user=$1
	local browser=$2

	homedir="$(getent passwd $user | cut -d: -f6)"
	group="$(stat -c %G $homedir)"

	# reset global variables and arrays
	unset profileArr DIRArr
	PSNAME=
	BACKUP=
	DIR=

	# skip homeless users
	if [[ -z $homedir ]]; then
		return
	fi

	case "$browser" in
		chromium|midori)
			DIRArr[0]="$homedir/.config/$browser"
			PSNAME="$browser"
			;;
		google-chrome)
			DIRArr[0]="$homedir/.config/$browser"
			PSNAME="chrome"
			;;
		firefox)
			if [[ -d $homedir/.mozilla/firefox ]]; then
				profileArr=( $(grep '[P,p]'ath= $homedir/.mozilla/firefox/profiles.ini|sed 's/[P,p]ath=//') )
				index=0
				PSNAME="$browser"
				for profileItem in ${profileArr[@]}; do
					if [[ $(echo $profileItem | cut -c1) = "/" ]]; then
						DIRArr[index]="$profileItem"	# path is not relative
					else
						DIRArr[index]="$homedir/.mozilla/firefox/$profileItem"	# we need to append the default path to give a fully qualified path
					fi
					index=$index+1
				done
			fi
			;;
		heftig-aurora)
			# https://bbs.archlinux.org/viewtopic.php?id=117157
			if [[ -d $homedir/.mozilla/aurora ]]; then
				profileArr=( $(grep '[P,p]'ath= $homedir/.mozilla/aurora/profiles.ini|sed 's/[P,p]ath=//') )
				index=0
				PSNAME="aurora"
				for profileItem in ${profileArr[@]}; do
					if [[ $(echo $profileItem | cut -c1) = "/" ]]; then
						DIRArr[index]="$profileItem"	# path is not relative
					else
						DIRArr[index]="$homedir/.mozilla/aurora/$profileItem"	# we need to append the default path to give a fully qualified path
					fi
					index=$index+1
				done
			fi
			;;
		opera|opera-next|qupzilla)
			DIRArr[0]="$homedir/.$browser"
			PSNAME="$browser"
			;;
		conkeror.mozdev.org)
			DIRArr[0]="$homedir/.$browser"
			PSNAME="xulrunner"
			;;
		*)
			# skip invalid browser entries
			return
	esac
}

running_check() {
	# check for browsers running and refuse to start if so
	# without this cannot guarantee profile integrity
	local browser user
	for user in $USERS; do
		for browser in $BROWSERS; do
			set_which "$user" "$browser"
			if [[ -n "$PSNAME" ]] && pgrep -u "$user" "$PSNAME" &>/dev/null; then
				echo "Refusing to start; $browser is running by $user!"
				exit 1
			else
				/bin/true
			fi
		done
	done
}

dup_check() {
	# only for firefox and aurora
	# the LAST directory in the profile MUST be unique
	# make sure there are no duplicates in ~/.mozilla/<browser>/profiles.ini
	local browser user
	for user in $USERS; do
		for browser in $BROWSERS; do
			set_which "$user" "$browser"
			if [[ "$browser" = "firefox" ]] || [[ "$browser" = "heftig-aurora" ]]; then
				if [[ -z ${DIRArr[@]} ]]; then
					/bin/true # nothing to check
				else
					# browser is on system so check profiles
					#
					# check that the LAST DIRECTORY in the full path is unique
					unique_count=$(echo ${DIRArr[@]##*/} | sed 's/ /\n/g' | sort | uniq | wc -l)
					if [[ ${#DIRArr[@]##*/} -eq $unique_count ]]; then
						/bin/true	# no problems so do nothing
					else
						echo -e " ${RED}Error: ${NRM}${BLD}dup profile for ${GRN}$browser${NRM}${BLD} detected. See psd manpage, correct, and try again."${NRM}
						[[ "$browser" = "heftig-aurora" ]] && browser="${browser##*-}"	# clip of the 'heftig-' to give correct path
						echo -e " ${BLD}Must have unique last directories in ${YLW}$homedir/.mozilla/$browser/profiles.ini${NRM}${BLD} to use psd."${NRM}
						exit 1
					fi
				fi
			fi
		done
	done
}

kill_browsers() {
	# check for browsers running and kill them to safely sync/unsync
	# without this cannot guarantee profile integrity
	local browser user
	for user in $USERS; do
		for browser in $BROWSERS; do
			set_which "$user" "$browser"

			x=1
			while [[ $x -le 5 ]]; do
				if [[ -n "$PSNAME" ]] && pgrep -u "$user" "$PSNAME" &>/dev/null; then
					pkill -SIGTERM -u "$user" "$PSNAME"
				else
					/bin/true
				fi
				x=$(( $x + 1 ))
			done
			### Do we need a secondary, more powerful method of killing if the first fails?
		done
	done
}

parse_conf_file() {
	echo -e "${RED}Profile-sync-daemon v$VERS${NRM}"
	echo
	echo -e "${BLD}Psd will manage the following per ${YLW}/etc/psd.conf${NRM}${BLD} settings:"${NRM}
	echo
	local browser user
	for user in $USERS; do
		for browser in $BROWSERS; do
			set_which "$user" "$browser"
			for item in ${DIRArr[@]}; do
				DIR="$item"
				[[ "$browser" = "firefox" ]] || [[ "$browser" = "heftig-aurora" ]] && suffix="-${item##*/}" || suffix=
				psize=$(du -Lh --max-depth=0 $DIR 2>/dev/null | gawk '{ print $1 }')	# profile dir size
				if [[ -d "$DIR" ]]; then
					echo -en " ${BLD}browser/psname:"
					echo -e "$(tput cr)$(tput cuf 17) $browser/$PSNAME"${NRM}
					echo -en " ${BLD}owner/group:"    
					echo -e "$(tput cr)$(tput cuf 17) $user/$group"${NRM} 
					echo -en " ${BLD}sync target:"
					echo -e "$(tput cr)$(tput cuf 17) ${YLW}$DIR"${NRM} 
					echo -en " ${BLD}tmpfs dir:"
					echo -e "$(tput cr)$(tput cuf 17) ${RED}$VOLATILE/$user-$browser$suffix"${NRM}
					echo -en " ${BLD}profile size:"
					echo -e "$(tput cr)$(tput cuf 17) $psize"${NRM} 
					echo
				fi
			done
		done
	done
}

ungraceful_state_check() {
	# if the machine was ungracefully shutdown then the backup will be on the filesystem
	# and the link to tmpfs will be on the filesystem but the contents will be empty
	# we need to simply remove the link and rotate the backup into place

	root_check
	local browser user suffix
	for user in $USERS; do
		for browser in $BROWSERS; do
			set_which "$user" "$browser"
			for item in ${DIRArr[@]}; do
				DIR="$item"
				BACKUP="$item-backup"
				[[ "$browser" = "firefox" ]] || [[ "$browser" = "heftig-aurora" ]] && suffix="-${item##*/}" || suffix=

				if [[ -e "$DIR/.flagged" ]]; then # all is well so continue
					/bin/true
				else
					[[ -h "$DIR" ]] && unlink "$DIR"
					[[ -d "$BACKUP" ]] && mv "$BACKUP" "$DIR"
				fi
			done
		done
	done
}

do_sync() {
	root_check
	touch "$DAEMON_FILE"

	local browser user
	for user in $USERS; do
		for browser in $BROWSERS; do
			set_which "$user" "$browser"
			for item in ${DIRArr[@]}; do
				DIR="$item"
				BACKUP="$item-backup"
				[[ "$browser" = "firefox" ]] || [[ "$browser" = "heftig-aurora" ]] && suffix="-${item##*/}" || suffix=

				# make tmpfs container
				if [[ -d $DIR ]]; then
					[[ -r "$VOLATILE/$user-$browser$suffix" ]] || install -dm755 --owner=$user --group=$group "$VOLATILE/$user-$browser$suffix"

					# backup target and link to tmpfs container
					if [[ $(readlink "$DIR") != "$VOLATILE/$user-$browser$suffix" ]]; then
						mv "$DIR" "$BACKUP"
						ln -s "$VOLATILE/$user-$browser$suffix" "$DIR"
						chown -h $user:$group "$DIR"
					fi

					# sync the tmpfs targets to the disc
					if [[ -e $DIR/.flagged ]]; then
						rsync -aog --delete-after --delay-updates --exclude .flagged "$DIR/" "$BACKUP/"
					else
						# initial sync
						# keep user from launching browser while rsync is active
						chmod -rwx $DIR
						rsync -aog --delay-updates "$BACKUP/" "$DIR/"
						chmod +rwx $DIR
						touch "$DIR/.flagged"
					fi
				fi
			done
		done
	done
}

do_unsync() {
	root_check
	rm -f "$DAEMON_FILE"

	local browser user
	for user in $USERS; do
		for browser in $BROWSERS; do
			set_which "$user" "$browser"
			for item in ${DIRArr[@]}; do
				DIR="$item"
				BACKUP="$item-backup"
				[[ "$browser" = "firefox" ]] || [[ "$browser" = "heftig-aurora" ]] && suffix="-${item##*/}" || suffix=

				# check if user has browser profile
				if [[ -h "$DIR" ]]; then
					unlink "$DIR"
					# this assumes that the backup is always updated so be sure to invoke a sync before an unsync
					#
					# restore original dirtree
					[[ -d "$BACKUP" ]] && mv "$BACKUP" "$DIR"
					[[ -d "$VOLATILE/$user-$browser$suffix" ]] && rm -rf "$VOLATILE/$user-$browser$suffix"
				fi
			done
		done
	done
}

case "$1" in
	p|P|Parse|parse|debug)
		dup_check && parse_conf_file
		;;
	sync)
		[[ ! -f $DAEMON_FILE ]] && dup_check && running_check && ungraceful_state_check
		do_sync
		;;
	resync)
		[[ -f $DAEMON_FILE ]] && do_sync
		;;
	unsync)
		[[ -f $DAEMON_FILE ]] && do_sync && kill_browsers
		do_unsync
		;;
	*) 
		echo -e "${RED}Profile-sync-daemon v$VERS${NRM}"
		echo
		echo -e " ${BLD}$0 ${NRM}${GRN}{parse|sync|unsync}${NRM}"
		echo
		echo -e " ${BLD}parse)  ${NRM}${GRN}Parse${NRM}${BLD} config file (${NRM}${YLW}/etc/psd.conf${NRM}${BLD}) to see which profiles will be managed."${NRM}
		echo -e " ${BLD}sync)   Force a manual ${NRM}${GRN}sync${NRM}${BLD}. Must be run as root user and NOT recommended."${NRM}
		echo -e " ${BLD}unsync) Force a manual ${NRM}${GRN}unsync${NRM}${BLD}. Must be run as root user and NOT recommended."${NRM}
		;;
esac
exit 0
