#!/bin/bash
readonly PATH=/usr/bin:/bin
readonly IFS=$' \t\n'

# Utility to capture directory identity
get_inode() {
    stat -c '%i' "$1" 2>/dev/null
}

while getopts :v:l:u:w:d: OPT; do
  case $OPT in
    v|+v) declare -ir OLFSVER=$OPTARG ;;
    l|+l) readonly BACKUP=$OPTARG ;;
    u|+u) readonly UPPER=$OPTARG ;;
    w|+w) readonly WORK=$OPTARG ;;
    d|+d) readonly TMP=$OPTARG ;;
    *) exit 1 ;;
  esac
done
shift $(( OPTIND - 1 ))
OPTIND=1

case "$1" in
  mountup)
    user=$(stat -c %U "$TMP")
    for dir in "$BACKUP" "$UPPER"; do
      if ! sudo -u "$user" test -w "$dir"; then
        echo "Error: User $user has no write permissions for $dir." >&2
        exit 1
      fi
    done

    if [[ $OLFSVER -eq 23 ]]; then
      mount -o nosuid,nodev -t overlay overlaid -olowerdir="$BACKUP",upperdir="$UPPER",workdir="$WORK" "$TMP"
    elif [[ $OLFSVER -eq 22 ]]; then
      mount -o nosuid,nodev -t overlayfs overlaid -olowerdir="$BACKUP",upperdir="$UPPER" "$TMP"
    fi
    ;;

  mountdown)
    caller_uid="${SUDO_UID:-$(id -u)}"

    if [[ -z "$WORK" || -z "$TMP" ]]; then
        echo "Error: Missing required parameters (-w or -d)." >&2
        exit 1
    fi

    # 1. Canonicalization & Identity Capture
    clean_work=$(realpath -m "$WORK")
    initial_inode=$(get_inode "$clean_work")

    # 2. Kernel-side Mount Verification
    if ! findmnt -t overlay "$TMP" >/dev/null 2>&1; then
        echo "Security Error: Target '$TMP' is not an active OverlayFS mount." >&2
        exit 1
    fi

    active_opts=$(findmnt -n -t overlay "$TMP" -o OPTIONS)
    if [[ $OLFSVER -ne 22 ]]; then
        if [[ ! "$active_opts" =~ "workdir=$clean_work" ]]; then
            echo "Security Error: Path '$clean_work' is not registered for this mount." >&2
            exit 1
        fi
    fi

    # 3. Ownership Verification
    path_owner=$(stat -c '%u' "$clean_work" 2>/dev/null)
    if [[ "$path_owner" != "$caller_uid" ]]; then
        echo "Security Error: Ownership mismatch (UID $path_owner vs $caller_uid)." >&2
        exit 1
    fi

    # 4. Safe Unmount & Anti-TOCTOU check
    if umount "$TMP"; then
        current_inode=$(get_inode "$clean_work")
        if [[ "$initial_inode" != "$current_inode" ]]; then
            echo "SECURITY ALERT: Race condition detected! Directory identity changed." >&2
            exit 1
        fi

        # 5. Final Secure Deletion
        rm -rf --one-file-system "$clean_work"
    else
        echo "Error: Failed to unmount '$TMP'. Aborting cleanup." >&2
        exit 1
    fi
    ;;

  *)
    echo "Internal PSD helper. Do not call directly."
    exit 0
    ;;
esac